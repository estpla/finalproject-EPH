## √çndice

0. [Ficha del proyecto](#0-ficha-del-proyecto)
1. [Descripci√≥n general del producto](#1-descripci√≥n-general-del-producto)
2. [Arquitectura del sistema](#2-arquitectura-del-sistema)
3. [Modelo de datos](#3-modelo-de-datos)
4. [Especificaci√≥n de la API](#4-especificaci√≥n-de-la-api)
5. [Historias de usuario](#5-historias-de-usuario)
6. [Tickets de trabajo](#6-tickets-de-trabajo)
7. [Pull requests](#7-pull-requests)
7. [Pull requests](#7-pull-requests)
8. [Extra - Sprint planning](#8-extra---sprint-planning)

---

## 0. Ficha del proyecto

### **0.1. Tu nombre completo:**

Esteban Platero Horcajadas

### **0.2. Nombre del proyecto:**

GymFlow (Gym Room Manager)

### **0.3. Descripci√≥n breve del proyecto:**

Se trata de una aplicaci√≥n en tiempo real para gimnasios, dise√±ada para gestionar y visualizar qu√© atletas est√°n entrenando en la sala en un momento dado. Al ingresar, cada atleta recibe autom√°ticamente su plan de entrenamiento personalizado, incluyendo ejercicios, pesos y repeticiones. El gestor de la sala puede a√±adir o retirar atletas manualmente, mientras que un monitor central muestra en vivo el estado y progreso de cada sesi√≥n. El sistema mejora la organizaci√≥n del gimnasio, optimiza el control del entrenamiento y proporciona una experiencia m√°s estructurada tanto para atletas como para entrenadores.

### **0.4. URL del proyecto:**

https://

> Puede ser p√∫blica o privada, en cuyo caso deber√°s compartir los accesos de manera segura. Puedes enviarlos a [alvaro@lidr.co](mailto:alvaro@lidr.co) usando alg√∫n servicio como [onetimesecret](https://onetimesecret.com/).

### 0.5. URL o archivo comprimido del repositorio

https://github.com/estpla/finalproject-EPH

---

## 1. Descripci√≥n general del producto

### **1.1. Objetivo:**

El objetivo del sistema es optimizar la gesti√≥n de entrenamientos en tiempo real dentro de salas de gimnasio o centros deportivos. Proporciona una herramienta centralizada que permite a los gestores controlar qui√©nes est√°n presentes en la sala, qu√© rutina debe seguir cada atleta, y c√≥mo evoluciona su entrenamiento durante la sesi√≥n.

* Qu√© valor aporta:
    - Mejora la organizaci√≥n y visibilidad en la sala de entrenamiento.
    - Automatiza la entrega de planes personalizados sin intervenci√≥n manual del entrenador.
    - Aumenta el control y seguimiento del rendimiento de los atletas.
    - Facilita la coordinaci√≥n entre gestores, entrenadores y atletas mediante una √∫nica plataforma visual y operativa.
    - Motiva al atleta al mostrar su progreso de forma clara y en tiempo real.

* Qu√© soluciona:
    - Falta de visibilidad sobre qui√©n est√° entrenando y en qu√© etapa.
    - Gesti√≥n manual e informal de rutinas de entrenamiento.
    - Dificultades para seguir el progreso o cumplimiento del plan durante la sesi√≥n.
    - Necesidad de supervisi√≥n constante por parte del entrenador.

* Para qui√©n:
    - Gestores de sala o responsables operativos en centros deportivos.
    - Entrenadores y preparadores f√≠sicos que dise√±an y asignan rutinas.
    - Atletas que siguen planes personalizados de entrenamiento.
    - Centros deportivos que buscan profesionalizar la experiencia en sala.

### **1.2. Caracter√≠sticas y funcionalidades principales:**

1. Gesti√≥n en tiempo real de atletas activos
    - A√±adir o quitar atletas que se encuentran entrenando en la sala.
    - Visualizaci√≥n inmediata del estado de cada atleta en la plataforma.
2. Asignaci√≥n autom√°tica del plan de entrenamiento
    - Al ingresar, el atleta accede autom√°ticamente a su rutina personalizada.
    - Rutinas con ejercicios detallados: series, repeticiones, peso, descanso.
3. Visualizaci√≥n en monitor de sala
    - Pantalla principal donde se muestra el estado de todos los atletas activos.
    - Interfaz clara y din√°mica, pensada para monitores o televisores.
4. Progreso de sesi√≥n en tiempo real
    - El atleta marca el avance de sus ejercicios desde su dispositivo o terminal.
    - Indicadores visuales de progreso para motivaci√≥n y control.
5. Editor de planes de entrenamiento
    - Herramienta para que los entrenadores dise√±en rutinas.
    - Posibilidad de crear, modificar y asignar planes a distintos perfiles.
6. Historial de entrenamiento
    - Registro autom√°tico de cada sesi√≥n realizada por el atleta.
    - Permite an√°lisis de consistencia, cumplimiento y evoluci√≥n f√≠sica.
7. Roles de usuario y permisos
    - Diferenciaci√≥n entre gestores, entrenadores y atletas.
    - Control de acceso a funcionalidades seg√∫n rol.
8. Dise√±o adaptable y visualmente optimizado
    - Interfaces pensadas para pantallas grandes, tablets y dispositivos m√≥viles.
    - Uso de colores e iconograf√≠a clara para facilitar la comprensi√≥n.

### **1.3. Dise√±o y experiencia de usuario:**

> Proporciona im√°genes y/o videotutorial mostrando la experiencia del usuario desde que aterriza en la aplicaci√≥n, pasando por todas las funcionalidades principales.

### **1.4. Instrucciones de instalaci√≥n:**

> Documenta de manera precisa las instrucciones para instalar y poner en marcha el proyecto en local (librer√≠as, backend, frontend, servidor, base de datos, migraciones y semillas de datos, etc.)

---

## 2. Arquitectura del Sistema

### **2.1. Diagrama de arquitectura:**

1. Arquitectura elegida

üß† Cliente-Servidor: Evaluaci√≥n de la Arquitectura

‚úÖ Por qu√© es una buena elecci√≥n para este proyecto
1. Separaci√≥n de responsabilidades clara
    - El cliente se encarga de la experiencia de usuario.
    - El servidor gestiona l√≥gica, datos, reglas de negocio.
2. Escalabilidad razonable
    - Puedes escalar el frontend y backend por separado si es necesario.
    - Puedes mover el backend a un microservicio en el futuro.
3. Tecnolog√≠as populares y maduras
    - Node.js, Next.js, PostgreSQL y Prisma tienen comunidades amplias, documentaci√≥n s√≥lida y f√°cil hosting.
4. Adaptado para MVPs
    - Suficiente simplicidad para entregar r√°pido sin sacrificar arquitectura limpia.
5. Buen soporte para tiempo real
    - Con WebSockets (socket.io), puedes lograr una interfaz viva sin complejidad extrema.

‚ùå Sacrificios y d√©ficits
1. Mayor complejidad que un stack monol√≠tico full-stack simple
    - Separar backend y frontend implica gesti√≥n de CORS, tokens, sesiones, etc.
2. Latencia entre cliente y servidor
    - Cualquier interacci√≥n (aunque sea ligera) requiere viaje a servidor. Para tiempo real, hay que optimizar esto (usando WebSockets o suscripciones).
3. Gesti√≥n de estado duplicado (cliente-servidor)
    - Si el estado no se sincroniza bien, puede haber errores de UX. Esto requiere buena arquitectura de frontend (React context, swr, tanstack-query).
4. Despliegue en m√∫ltiples entornos
    - Necesitas coordinar despliegue del frontend (Vercel, por ejemplo) y backend (Render, Railway, etc.).

üèÅ Resumen
‚úÖ Es una buena elecci√≥n porque: es modular, escalable, extensible y va bien con tu stack y necesidades (tiempo real, gesti√≥n, visualizaci√≥n).
‚ö†Ô∏è Los desaf√≠os est√°n en la sincronizaci√≥n de estado, el despliegue y el tiempo real, pero son abordables y no excesivos para un MVP.

2. C4 - Nivel 1: Diagrama de Contexto

```
[Usuario: Gestor/Entrenador] --> (Aplicaci√≥n Web - Backoffice)
[Usuario: Atleta] --> (Pantalla de Visualizaci√≥n / Terminal de Progreso)

(Aplicaci√≥n Web) --> (API REST/Express)
(API REST) --> (Base de Datos PostgreSQL)
```

3. C4 - Nivel 2: Diagrama de Contenedores

```
+----------------------------+         
|        Navegador          |         
|  (Next.js - Cliente)      |         
|  - Backoffice UI          |         
|  - Monitor Visual         |         
+------------+--------------+         
             |                         
             v                         
+------------+--------------+         
|   Servidor de Aplicaci√≥n  |         
|    Node.js + Express      |         
|  - API REST / RPC Layer   |         
|  - WebSocket Server (op.) |         
|  - Autenticaci√≥n JWT      |         
+------------+--------------+         
             |                         
             v                         
+------------+--------------+         
|      PostgreSQL (DB)      |         
| - Usuarios                |         
| - Atletas                 |         
| - Planes y ejercicios     |         
| - Sesiones activas        |         
| - Historial/progreso      |         
+---------------------------+         
```

![Architectural Diagram](docs/images/architectural-diagram.png)

### **2.2. Descripci√≥n de componentes principales:**

üß± Arquitectura Cliente-Servidor para MVP
üîß Tecnolog√≠as
- Backend: Node.js + Express, PostgreSQL, Prisma (ORM)
- Frontend: Next.js + React, Shadcn/UI, TailwindCSS

üìê Componentes arquitect√≥nicos necesarios
1. Cliente (Frontend)
Separado en dos interfaces:
üñ•Ô∏è 1.1. Monitor de Sala (Pantalla de Visualizaci√≥n en Tiempo Real)
- Aplicaci√≥n Next.js sin login, modo "pantalla completa".
- Suscripci√≥n o polling para recibir datos actualizados de atletas y progreso.
- Auto-refresh o WebSocket para mostrar cambios en tiempo real.
- Layout adaptado a TV/monitor con rotulaci√≥n clara.

üßë‚Äçüíº 1.2. Backoffice (Gesti√≥n de Atletas y Planes)
- Aplicaci√≥n Next.js con login (gestor/entrenador).
- Interfaz para:
    - A√±adir/quitar atletas de la sala.
    - Crear/asignar planes de entrenamiento.
    - Ver historial.
Requiere protecci√≥n de rutas (middleware) y panel de control tipo dashboard.

2. Servidor (Backend - API REST o RPC)
Usando Node.js + Express + Prisma + PostgreSQL.
2.1. API Layer
- Rutas REST o API Routes en Next.js (si quieres minimizar Express).
- Endpoints principales:
    - /athletes/active: obtener atletas activos.
    - /session/start, /session/end: controlar presencia.
    - /workouts/{id}: obtener detalles de rutina.
    - /progress: guardar progreso.
    - /plans: CRUD de planes de entrenamiento.
- Protecciones por rol (middleware de autenticaci√≥n/autorizaci√≥n).

2.2. Realtime Layer (opcional para MVP)
- Opci√≥n 1: Polling simple desde frontend (cada X segundos).
- Opci√≥n 2 (mejor UX): WebSocket con socket.io para emitir cambios a la sala.

2.3. ORM / Base de Datos
- Prisma conectado a PostgreSQL.
- Migraciones y seed para datos iniciales.
- Relaciones b√°sicas:
    - User (gestores, entrenadores)
    - Athlete
    - Plan ‚ûù con lista de Exercise
    - Session ‚ûù atleta activo en sala
    - Progress (registro por ejercicio)

3. Base de Datos (PostgreSQL)
- Relacional y bien adaptada a planes y seguimiento.
- Tablas principales:
    - users, athletes, plans, exercises, sessions, progress_logs
- Prisma se encarga del acceso y mantenimiento del esquema.

4. Autenticaci√≥n
- JWT (con almacenamiento en cookies seguras) o next-auth para facilidad.
- Roles definidos en el token: admin, coach, monitor.

5. Deploy / Hosting
- Frontend: Vercel (ideal para Next.js).
- Backend + DB: Railway, Render, Supabase o incluso Vercel API routes si quieres un stack simplificado.
- PostgreSQL: Supabase, Neon o Railway DB para MVP.

üîÅ Resumen del Flujo
1. El gestor inicia sesi√≥n desde el backoffice (Next.js).
2. A√±ade atletas a la sala ‚ûù Se crea sesi√≥n activa en backend.
3. El monitor de sala recibe (por polling o WebSocket) el estado actualizado.
4. El atleta ve su rutina y marca progreso (v√≠a terminal o backend).
5. Al terminar, se cierra la sesi√≥n ‚ûù queda registrada en el historial.

### **2.3. Descripci√≥n de alto nivel del proyecto y estructura de ficheros**

üèóÔ∏è Descripci√≥n General:
GymFlow es una plataforma cliente-servidor para la gesti√≥n en tiempo real de atletas dentro de una sala de entrenamiento. Ofrece una vista operativa clara de qui√©nes est√°n activos, qu√© ejercicios deben realizar y c√≥mo progresa cada sesi√≥n. Incluye una interfaz p√∫blica para mostrar en monitores y un panel de gesti√≥n privado para entrenadores y gestores.

üéØ Objetivos Clave:
- Gestionar atletas activos en la sala.
- Asignar y visualizar rutinas personalizadas.
- Mostrar el estado de la sala en tiempo real.
- Permitir al gestor controlar los flujos de entrenamiento desde un backoffice.

üß∞ Stack Tecnol√≥gico:
- Frontend: React + Next.js, Shadcn, TailwindCSS
- Backend: Node.js + Express
- ORM: Prisma
- DB: PostgreSQL
- Autenticaci√≥n: JWT (o NextAuth si se quiere integrar f√°cilmente en Next.js)
- Realtime: WebSocket (con Socket.io o alternativa)
- Deploy: Vercel (frontend), Railway/Render (backend), Supabase/Neon (DB)

```
/frontend
‚îú‚îÄ‚îÄ public/                  # Im√°genes, √≠conos, logos
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ app/                 # Rutas de Next.js (App Router)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dashboard/       # Backoffice para gesti√≥n
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ monitor/         # Vista de sala para TV/monitor
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/             # Endpoints si se decide usar API Routes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx         # P√°gina principal o login
‚îÇ   ‚îú‚îÄ‚îÄ components/          # Componentes UI reutilizables
‚îÇ   ‚îú‚îÄ‚îÄ features/            # M√≥dulos separados por dominio (e.g. athletes, sessions)
‚îÇ   ‚îú‚îÄ‚îÄ hooks/               # React hooks personalizados
‚îÇ   ‚îú‚îÄ‚îÄ lib/                 # Funciones utilitarias, conexi√≥n API, auth
‚îÇ   ‚îú‚îÄ‚îÄ styles/              # Archivos de estilos (Tailwind config)
‚îÇ   ‚îî‚îÄ‚îÄ config/              # Configuraci√≥n de roles, rutas protegidas, etc.
‚îú‚îÄ‚îÄ .env.local
‚îú‚îÄ‚îÄ tailwind.config.js
‚îî‚îÄ‚îÄ next.config.js
```

```
/backend
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ controllers/         # L√≥gica de negocio (e.g. sessionController.js)
‚îÇ   ‚îú‚îÄ‚îÄ routes/              # Rutas Express (e.g. /sessions, /athletes)
‚îÇ   ‚îú‚îÄ‚îÄ services/            # L√≥gica de dominio (e.g. workout assignment)
‚îÇ   ‚îú‚îÄ‚îÄ middlewares/         # Auth, errores, validaciones
‚îÇ   ‚îú‚îÄ‚îÄ sockets/             # Configuraci√≥n WebSocket (e.g. socket.io)
‚îÇ   ‚îú‚îÄ‚îÄ utils/               # Funciones auxiliares (fechas, tokens, etc.)
‚îÇ   ‚îú‚îÄ‚îÄ prisma/              # Esquema y cliente de Prisma
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ schema.prisma
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ seed.ts
‚îÇ   ‚îú‚îÄ‚îÄ index.ts             # Punto de entrada principal del servidor
‚îÇ   ‚îî‚îÄ‚îÄ server.ts            # Setup de Express, middleware, rutas
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ tsconfig.json
‚îî‚îÄ‚îÄ package.json
```

üîê Autenticaci√≥n y Roles
- Los roles (admin, coach, viewer) se pueden manejar con un middleware en el backend y validaciones en el frontend.
- Usar JWT o NextAuth seg√∫n preferencia: JWT te da m√°s control, NextAuth m√°s rapidez de implementaci√≥n.

üß™ Extensiones Opcionales a futuro
- /mobile: carpeta para una app m√≥vil (React Native o Expo).
- /admin: consola administrativa m√°s avanzada si hay m√∫ltiples centros.
- /docs: documentaci√≥n t√©cnica y funcional del sistema (puede incluir Swagger para API).

### **2.4. Infraestructura y despliegue**

üåê Infraestructura con Render + Supabase (para MVP)
üß± Componentes Principales
1. Frontend ‚Äì App Next.js (React + Tailwind + Shadcn)
    - Desplegado en Render como Web Service est√°tico.
    - Se comunica con el backend a trav√©s de HTTP(S).
2. Backend ‚Äì API Node.js + Express + Prisma
    - Desplegado en Render como Web Service din√°mico.
    - Expone endpoints REST o API para el frontend.
    - Opcionalmente usa WebSocket para tiempo real.
3. Base de Datos ‚Äì PostgreSQL en Supabase
    - Administra usuarios, atletas, planes, sesiones, progreso, etc.
    - Prisma se conecta directamente a Supabase desde el backend.
4. Autenticaci√≥n (opcional) ‚Äì Puede usarse Supabase Auth o JWT.
    - Si usas Supabase Auth: se conecta v√≠a SDK.
    - Si usas JWT: el backend genera/verifica los tokens.

üó∫Ô∏è Diagrama de Infraestructura (Render + Supabase)

                                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                 ‚îÇ         Usuarios             ‚îÇ
                                 ‚îÇ (Gestores / Monitores / TVs) ‚îÇ
                                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                              ‚îÇ
                     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                     ‚îÇ                Render (Frontend)                ‚îÇ
                     ‚îÇ         Next.js (Monitor + Backoffice)          ‚îÇ
                     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                      ‚îÇ API HTTP calls / WebSocket
                     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                     ‚îÇ                 Render (Backend)                ‚îÇ
                     ‚îÇ         Node.js + Express + Prisma              ‚îÇ
                     ‚îÇ       API REST / WS / Auth middleware           ‚îÇ
                     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                      ‚îÇ Prisma connection
                     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                     ‚îÇ         Supabase (PostgreSQL)     ‚îÇ
                     ‚îÇ - Athletes, Plans, Sessions, Logs ‚îÇ
                     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

üöÄ Proceso de Despliegue
üß© 1. Preparaci√≥n del Proyecto
    - El proyecto est√° dividido en dos carpetas:
        - /frontend: aplicaci√≥n Next.js
        - /backend: aplicaci√≥n Express + Prisma
üõ†Ô∏è 2. Desplegar la Base de Datos (Supabase)
    - Crear un proyecto en Supabase.
    - Crear base de datos PostgreSQL.
    - Copiar la connection string para usarla en .env del backend.
    - Opcional: definir autenticaci√≥n, roles, restricciones.
‚òÅÔ∏è 3. Desplegar Backend en Render
    - Ir a https://render.com.
    - Crear un Web Service nuevo con el repositorio /backend.
    - Variables de entorno necesarias:
        - DATABASE_URL ‚Üí desde Supabase
        - PORT ‚Üí usualmente 10000 o definido por Render
        - JWT_SECRET, etc.
    - Activar "auto deploy" desde GitHub (opcional).
    - Asegurarse de que escucha en process.env.PORT.
üåç 4. Desplegar Frontend en Render
    - Crear otro Web Service o Static Site para /frontend.
        - Si usas next export: Static Site.
        - Si usas SSR (getServerSideProps): Web Service (Node).
    - Variables de entorno:
        - NEXT_PUBLIC_API_URL ‚Üí URL del backend desplegado
        - NEXT_PUBLIC_WS_URL ‚Üí si usas WebSocket
    - Configurar el build command: npm run build
    - Output dir: .next o out si haces export.

‚úÖ Resumen de Beneficios
- Render: hosting sencillo, integraci√≥n con GitHub, soporte para Node y WebSocket.
- Supabase: DB potente, con panel amigable, backups y auth opcional.
- Separaci√≥n de responsabilidades: backend flexible y frontend optimizado.

### **2.5. Seguridad**

> Enumera y describe las pr√°cticas de seguridad principales que se han implementado en el proyecto, a√±adiendo ejemplos si procede

üõ°Ô∏è 1. Autenticaci√≥n y Autorizaci√≥n Segura
‚úÖ Pr√°cticas:
- Usar tokens JWT con expiraci√≥n corta (ej. 15‚Äì60 min).
- Almacenar tokens en httpOnly cookies (mejor que en localStorage).
- Control de acceso por roles (ej. admin, coach, viewer).
- Validar el rol en cada endpoint backend.
üß† Ejemplo:
```ts
// Express middleware
const requireAuth = (role: 'admin' | 'coach') => (req, res, next) => {
  const token = req.cookies.token;
  const user = jwt.verify(token, process.env.JWT_SECRET);
  if (!user || user.role !== role) return res.status(403).send('Forbidden');
  req.user = user;
  next();
};
```

üîí 2. Seguridad en la Base de Datos
‚úÖ Pr√°cticas:
- Usar un ORM seguro como Prisma (evita SQL Injection).
- Limitar privilegios del usuario de la base de datos.
- Escapar siempre inputs antes de hacer queries manuales.
- Uso de migraciones para cambios controlados.
üß† Ejemplo:
```ts
// Evita interpolar manualmente inputs
await prisma.user.findFirst({ where: { email: input.email } });
```

üåê 3. Seguridad Web (Frontend y API)
‚úÖ Pr√°cticas:
- CORS configurado expl√≠citamente para solo permitir dominios confiables.
- Rate limiting en rutas cr√≠ticas (login, sesiones).
- CSRF protection si usas cookies.
- Validar el tipo de contenido recibido en el backend.

üß† Ejemplo (CORS en Express):
```ts
app.use(cors({
  origin: ['https://tuapp.com'],
  credentials: true,
}));
```

üßæ 4. Validaci√≥n de Datos de Entrada
‚úÖ Pr√°cticas:
- Usar una librer√≠a de validaci√≥n como zod, joi o express-validator.
- Validar siempre antes de procesar o almacenar datos.
- Nunca confiar en datos del cliente.

üß† Ejemplo:
```ts
const schema = z.object({
  email: z.string().email(),
  weight: z.number().min(1),
});
schema.parse(req.body); // Lanzar√° excepci√≥n si no cumple
```

üîê 5. Almacenamiento Seguro de Credenciales y Tokens
‚úÖ Pr√°cticas:
- Usar variables de entorno (.env) y nunca subirlas a git.
- Usar dotenv o configuraci√≥n de Render/Supabase para secrets.
- Rotar secretos si hay filtraci√≥n.

üß† Ejemplo:
```ts
const token = jwt.sign({ userId: user.id }, process.env.JWT_SECRET, { expiresIn: '30m' });
```

üïµÔ∏è 6. Logs y Monitoreo de Actividad
‚úÖ Pr√°cticas:
- Registrar logins, accesos y errores con IP, userId y timestamps.
- No guardar contrase√±as, tokens o datos sensibles en logs.
- Usar herramientas como Sentry, LogRocket, Logtail, etc.

üß† Ejemplo:
```ts
logger.info(`Login attempt for ${email} from IP ${req.ip}`);
```

üì¶ 7. Dependencias y Paquetes Seguros
‚úÖ Pr√°cticas:
- Revisar dependencias con npm audit o snyk.
- No instalar paquetes sin reputaci√≥n o sin revisi√≥n.
- Actualizar regularmente (npm update).

üì± 8. Protecci√≥n en Realtime (WebSocket)
‚úÖ Pr√°cticas:
- Autenticar al usuario al abrir el socket (ej. enviar token).
- Filtrar eventos por rol (ej. un viewer no puede emitir eventos).
- Cerrar sockets inactivos o con actividad sospechosa.

üß† Ejemplo:
```ts
io.use((socket, next) => {
  const token = socket.handshake.auth.token;
  const user = jwt.verify(token, JWT_SECRET);
  if (!user) return next(new Error('Unauthorized'));
  socket.user = user;
  next();
});
```

üßØ 9. Backups y Recuperaci√≥n
‚úÖ Pr√°cticas:
- Usar los backups autom√°ticos de Supabase (plan pago si es cr√≠tico).
- Exportar la base de datos semanalmente como medida adicional.

‚úâÔ∏è 10. Prevenci√≥n de Fugas de Informaci√≥n
‚úÖ Pr√°cticas:
- No exponer detalles t√©cnicos en errores (stack traces, DB errors).
- Usar mensajes gen√©ricos para errores de login o permisos.
- Desactivar cabeceras innecesarias (ej. X-Powered-By en Express).

### **2.6. Tests**

üß™ 1. Tests de Backend (Node.js + Express + Prisma)
‚úÖ 1.1. Tests Unitarios
Qu√© probar: Funciones puras, validaciones, l√≥gica de negocio independiente (por ejemplo, c√°lculo de progresos, verificaci√≥n de rol).

Motivo:
- Detectan errores en la l√≥gica sin depender de la base de datos o la red.
- Son r√°pidos de ejecutar y dan feedback inmediato.

Ejemplo:
- Funci√≥n que calcula si un atleta ha completado una serie seg√∫n su plan.
- Middleware de autenticaci√≥n o autorizaci√≥n.

‚úÖ 1.2. Tests de Integraci√≥n
Qu√© probar: Interacci√≥n entre controladores, base de datos y servicios externos.

Motivo:
- Verifica que Prisma, Express y Supabase est√©n integrados correctamente.
- Asegura que las operaciones CRUD funcionan como se espera.

Ejemplo:
- Endpoint POST /sessions/start crea correctamente una sesi√≥n y relaciona al atleta.
- GET /workouts/:athleteId devuelve los ejercicios adecuados.

Herramientas sugeridas: Jest, Supertest, Prisma Test Utils, sqlite in-memory o base temporal.

üß© 2. Tests de Frontend (React + Next.js)
‚úÖ 2.1. Tests de Componentes (Unitarios)
Qu√© probar: Componentes individuales (ej. cards, botones, formularios).

Motivo:
- Aseguran que cada componente renderiza correctamente bajo diferentes props y estados.
- Detectan errores de UI tempranos.

Ejemplo:
- Componente WorkoutCard que muestra series, repeticiones y carga.
- UserList con props como lista vac√≠a o cargando.

Herramientas sugeridas: React Testing Library, Jest.

‚úÖ 2.2. Tests de Integraci√≥n de UI
Qu√© probar: Flujo entre varios componentes + estado.

Motivo:
- Verifica que interacciones del usuario actualicen la UI correctamente (sin llegar a ser tests end-to-end).
- √ötiles para la parte del monitor de sala y gesti√≥n de atletas.

Ejemplo:
- Hacer click en un atleta lo muestra en pantalla con sus ejercicios.
- A√±adir un ejercicio en el backoffice lo refleja en pantalla.

üåç 3. Tests End-to-End (E2E)
‚úÖ 3.1. Tests de Flujo Completo
Qu√© probar: Flujos reales del usuario con navegador simulado.

Motivo:
- Aseguran que todo el stack (frontend + backend + base de datos) funciona integrado.
- Cr√≠ticos para tareas clave como:
    - Iniciar una sesi√≥n de entrenamiento.
    - Actualizar el progreso de un ejercicio.
    - A√±adir un nuevo atleta desde el backoffice.

Herramientas sugeridas: Cypress, Playwright.

‚öôÔ∏è 4. Tests de API (opcionales si tienes E2E + integraci√≥n)
Qu√© probar: Comportamiento de los endpoints HTTP.

Motivo:
- √ötiles para documentar y validar la API si otros sistemas van a consumirla.
- Tambi√©n ayudan si decides usar Swagger/OpenAPI.

Herramientas: Supertest, Insomnia, Postman (Tests), Pact si usas contratos.

üß∞ Resumen: Tipos de Tests Recomendados por Prioridad

| Tipo de Test        | √Årea      | Herramientas sugeridas | Prioridad |
| ------------------- | --------- | ---------------------- | --------- |
| Unitarios           | Backend   | Jest                   | üü¢ Alta   |
| Integraci√≥n Backend | Backend   | Supertest, Prisma      | üü¢ Alta   |
| Unitarios de UI     | Frontend  | React Testing Library  | üü° Media  |
| Integraci√≥n de UI   | Frontend  | React Testing Library  | üü¢ Alta   |
| End-to-End          | Fullstack | Cypress / Playwright   | üü¢ Alta   |
| API Tests (REST)    | Backend   | Supertest / Postman    | ‚ö™Ô∏è Baja   |

---

## 3. Modelo de Datos

### **3.1. Diagrama del modelo de datos:**

```mermaid
erDiagram

  User {
    UUID id
    String name
    String email
    String password
    Enum role
  }

  Athlete {
    UUID id
    String name
    String email
    UUID activeSessionId
    Timestamp createdAt
  }

  Workout {
    UUID id
    String name
    UUID athleteId
    Timestamp createdAt
  }

  Exercise {
    UUID id
    String name
    String description
    Enum category
  }

  WorkoutExercise {
    UUID id
    UUID workoutId
    UUID exerciseId
    Int sets
    Int reps
    Float weight
    Int order
  }

  TrainingSession {
    UUID id
    UUID athleteId
    UUID workoutId
    Timestamp startedAt
    Timestamp endedAt
  }

  ExerciseProgress {
    UUID id
    UUID sessionId
    UUID exerciseId
    Int setsCompleted
    Float weightUsed
    Text notes
  }

  %% Relaciones
  Athlete ||--o{ Workout : "has"
  Athlete ||--o{ TrainingSession : "performs"
  Workout ||--o{ WorkoutExercise : "contains"
  WorkoutExercise }o--|| Exercise : "references"
  TrainingSession ||--o{ ExerciseProgress : "tracks"
  ExerciseProgress }o--|| Exercise : "for"
  User ||--o{ Athlete : "manages"
  TrainingSession }o--|| Workout : "based on"
```

![Mermaid Diagram](docs/images/mermaid-diagram.png)

### **3.2. Descripci√≥n de entidades principales:**

üß© Entidades Principales del Sistema
1. Atleta (Athlete)
Representa a un usuario que realiza entrenamientos en la sala.
| Campo             | Tipo      | Descripci√≥n                                |
| ----------------- | --------- | ------------------------------------------ |
| `id`              | UUID      | Identificador √∫nico                        |
| `name`            | String    | Nombre completo del atleta                 |
| `email`           | String    | Correo (opcional o para notificaciones)    |
| `activeSessionId` | UUID?     | Sesi√≥n activa actual en la sala (nullable) |
| `createdAt`       | Timestamp | Fecha de registro                          |


üîó Relaciones:
- Tiene muchas sesiones de entrenamiento (TrainingSession)
- Puede estar activo en la sala si tiene activeSessionId

2. Ejercicio (Exercise)
Define un tipo de ejercicio disponible (p. ej., "Press Banca").
| Campo         | Tipo   | Descripci√≥n                        |
| ------------- | ------ | ---------------------------------- |
| `id`          | UUID   | Identificador                      |
| `name`        | String | Nombre del ejercicio               |
| `description` | Text   | (opcional) descripci√≥n t√©cnica     |
| `category`    | Enum   | `upper_body`, `legs`, `core`, etc. |

üîó Relaciones:
Utilizado dentro de Workout como parte de una sesi√≥n

3. Plan de Entrenamiento (Workout)
Plantilla con ejercicios que debe realizar un atleta en una sesi√≥n.
| Campo       | Tipo      | Descripci√≥n                      |
| ----------- | --------- | -------------------------------- |
| `id`        | UUID      | Identificador                    |
| `name`      | String    | Nombre del plan (p.ej., ‚ÄúD√≠a A‚Äù) |
| `athleteId` | UUID      | A qui√©n va dirigido              |
| `createdAt` | Timestamp | Fecha de creaci√≥n                |

üîó Relaciones:
- Tiene muchos WorkoutExercise (ejercicios con series y repeticiones)

4. Ejercicio dentro de un Workout (WorkoutExercise)
Contiene la configuraci√≥n de un ejercicio en un plan.
| Campo        | Tipo  | Descripci√≥n           |
| ------------ | ----- | --------------------- |
| `id`         | UUID  | ID interno            |
| `workoutId`  | UUID  | Plan al que pertenece |
| `exerciseId` | UUID  | Tipo de ejercicio     |
| `sets`       | Int   | Series                |
| `reps`       | Int   | Repeticiones          |
| `weight`     | Float | Peso sugerido (kg)    |
| `order`      | Int   | Orden de ejecuci√≥n    |


5. Sesi√≥n Activa (TrainingSession)
Representa la entrada real de un atleta a la sala para ejecutar un plan.
| Campo       | Tipo      | Descripci√≥n                             |
| ----------- | --------- | --------------------------------------- |
| `id`        | UUID      | ID √∫nico                                |
| `athleteId` | UUID      | Qui√©n la est√° ejecutando                |
| `workoutId` | UUID      | Plan asignado                           |
| `startedAt` | Timestamp | Inicio de sesi√≥n                        |
| `endedAt`   | Timestamp | Fin de sesi√≥n (nullable si est√° activa) |

üîó Relaciones:
- Cada sesi√≥n tiene muchos ExerciseProgress

6. Progreso de Ejercicio (ExerciseProgress)
Representa el estado actual de ejecuci√≥n por ejercicio dentro de una sesi√≥n.
| Campo           | Tipo  | Descripci√≥n                  |
| --------------- | ----- | ---------------------------- |
| `id`            | UUID  | ID                           |
| `sessionId`     | UUID  | A qu√© sesi√≥n pertenece       |
| `exerciseId`    | UUID  | Qu√© ejercicio                |
| `setsCompleted` | Int   | Cu√°ntas series ha completado |
| `weightUsed`    | Float | Peso realmente usado         |
| `notes`         | Text  | Observaciones opcionales     |

7. Usuario de Gesti√≥n (User)
Representa a los gestores de la sala (admin, entrenador, etc.).
| Campo      | Tipo   | Descripci√≥n         |
| ---------- | ------ | ------------------- |
| `id`       | UUID   | Identificador       |
| `name`     | String | Nombre del usuario  |
| `email`    | String | Correo (para login) |
| `role`     | Enum   | `admin`, `coach`    |
| `password` | String | Hash de contrase√±a  |

üîó Relaciones Principales (Resumen Visual)
```md
User ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                 ‚îî‚îÄ> gestiona ‚îÄ‚îÄ> Athlete
Athlete ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ> tiene ‚îÄ‚îÄ> Workout
                 ‚îî‚îÄ> realiza ‚îÄ‚îÄ> TrainingSession ‚îÄ‚îÄ> ExerciseProgress
Workout ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îî‚îÄ> compuesto por ‚îÄ‚îÄ> WorkoutExercise ‚îÄ‚îÄ> Exercise
```

---

## 4. Especificaci√≥n de la API

```yaml
openapi: 3.0.3
info:
  title: Gym Session API
  version: 1.0.0
  description: API para gestionar sesiones de entrenamiento en un gimnasio

paths:

  /sessions/start:
    post:
      summary: Iniciar sesi√≥n de entrenamiento para un atleta
      description: Crea una nueva sesi√≥n activa para un atleta con un plan de entrenamiento asociado.
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                athleteId:
                  type: string
                workoutId:
                  type: string
              required:
                - athleteId
                - workoutId
      responses:
        '201':
          description: Sesi√≥n creada con √©xito
          content:
            application/json:
              schema:
                type: object
                properties:
                  sessionId:
                    type: string
                  startedAt:
                    type: string
                    format: date-time
                  athleteId:
                    type: string
                  workoutId:
                    type: string
        '400':
          description: Datos inv√°lidos o atleta ya en sesi√≥n

  /room/status:
    get:
      summary: Obtener estado actual de la sala
      description: Devuelve una lista de atletas que se encuentran entrenando en este momento y sus progresos.
      responses:
        '200':
          description: Lista de atletas en sala con progreso actual
          content:
            application/json:
              schema:
                type: array
                items:
                  type: object
                  properties:
                    athleteId:
                      type: string
                    name:
                      type: string
                    workoutName:
                      type: string
                    currentExercise:
                      type: string
                    setsCompleted:
                      type: integer
                    totalSets:
                      type: integer

  /progress/{sessionId}/{exerciseId}:
    patch:
      summary: Actualizar progreso de un ejercicio
      description: Permite actualizar las series completadas y el peso usado para un ejercicio dentro de una sesi√≥n.
      parameters:
        - in: path
          name: sessionId
          required: true
          schema:
            type: string
        - in: path
          name: exerciseId
          required: true
          schema:
            type: string
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                setsCompleted:
                  type: integer
                weightUsed:
                  type: number
                notes:
                  type: string
      responses:
        '200':
          description: Progreso actualizado correctamente
          content:
            application/json:
              schema:
                type: object
                properties:
                  status:
                    type: string
                  updatedAt:
                    type: string
                    format: date-time
        '404':
          description: Sesi√≥n o ejercicio no encontrado
```

üì¶ Ejemplos de uso
1. POST /sessions/start

Request:
```json
{
  "athleteId": "uuid-atleta-123",
  "workoutId": "uuid-workout-789"
}
```

Response:
```json
{
  "sessionId": "uuid-session-456",
  "startedAt": "2025-05-14T10:12:00Z",
  "athleteId": "uuid-atleta-123",
  "workoutId": "uuid-workout-789"
}
```

2. GET /room/status

Response:
```json
[
  {
    "athleteId": "uuid-1",
    "name": "Mar√≠a Torres",
    "workoutName": "D√≠a A - Fuerza",
    "currentExercise": "Press de Banca",
    "setsCompleted": 2,
    "totalSets": 4
  },
  {
    "athleteId": "uuid-2",
    "name": "Carlos L√≥pez",
    "workoutName": "Pierna explosiva",
    "currentExercise": "Sentadilla",
    "setsCompleted": 3,
    "totalSets": 5
  }
]
```

3. PATCH /progress/{sessionId}/{exerciseId}

Request:
```json
{
  "setsCompleted": 3,
  "weightUsed": 80.5,
  "notes": "Aumentar peso la pr√≥xima sesi√≥n"
}
```

Response:
```json
{
  "status": "updated",
  "updatedAt": "2025-05-14T11:25:40Z"
}
```

---

## 5. Historias de Usuario

**Historia de Usuario 1**

# User Story Title: Iniciar una sesi√≥n de entrenamiento

1. **como atleta registrado**,
2. **quiere** iniciar una sesi√≥n de entrenamiento con su plan asignado,
3. **para que** pueda registrar su progreso y ser visible en el estado de la sala.

# Criterios de aceptaci√≥n:

1. El sistema debe permitir al atleta iniciar una sesi√≥n si no tiene otra sesi√≥n activa.
2. La sesi√≥n debe estar vinculada al plan de entrenamiento seleccionado.
3. El sistema debe devolver el ID de la sesi√≥n y la hora de inicio.

# Notas adicionales:

- Si el atleta ya tiene una sesi√≥n activa, el sistema debe devolver un error claro.
- Esta funcionalidad podr√≠a iniciarse mediante una tablet, un terminal t√°ctil o un lector de credenciales en la sala.

# Historias de usuario relacionadas:

- Obtener estado de la sala
- Actualizar progreso de ejercicios

**Historia de Usuario 2**

# User Story Title: Ver el estado actual de la sala

1. **como gestor de sala**,
2. **quiere** ver en tiempo real qu√© atletas est√°n entrenando y en qu√© parte del plan se encuentran,
3. **para que** pueda supervisar la actividad y ayudar si es necesario.

# Criterios de aceptaci√≥n:

1. El sistema debe mostrar la lista de atletas actualmente activos.
2. Debe incluir el nombre del ejercicio actual, el progreso y el nombre del plan.
3. Los datos deben actualizarse sin necesidad de recargar manualmente.

# Notas adicionales:

- Esta funcionalidad se mostrar√° en un monitor de la sala para todos los usuarios.
- Puede incluirse una vista simplificada tipo "pizarra" o "dashboard de sala".

# Historias de usuario relacionadas:

- Iniciar una sesi√≥n de entrenamiento
- Actualizar progreso de ejercicios

**Historia de Usuario 3**

# User Story Title: Actualizar el progreso de un ejercicio

1. **como atleta en sesi√≥n**,
2. **quiere** registrar las series completadas y el peso usado en cada ejercicio,
3. **para que** pueda llevar un control preciso de su entrenamiento.

# Criterios de aceptaci√≥n:

1. El sistema debe permitir actualizar solo ejercicios dentro de sesiones activas.
2. Debe validar que los datos ingresados son consistentes (e.g., sets >= 0).
3. Debe devolver un mensaje de confirmaci√≥n y la hora de la √∫ltima actualizaci√≥n.

# Notas adicionales:

- Esto puede ser usado desde el m√≥vil del atleta o desde una estaci√≥n compartida en sala.
- Se recomienda guardar un historial para an√°lisis posteriores.

# Historias de usuario relacionadas:

- Iniciar una sesi√≥n de entrenamiento
- Ver el estado actual de la sala

**Requisitos t√©cnicos**

üß† Requisitos T√©cnicos del Sistema
1. Backend (Node.js + Express + Prisma + PostgreSQL)
üìå Funcionalidades
- Crear sesi√≥n de entrenamiento
    - Endpoint POST /sessions/start para validar que el atleta no tiene una sesi√≥n activa.
    - L√≥gica para asignar un plan (Workout) a una nueva sesi√≥n (TrainingSession).
    - Registro autom√°tico de startedAt.
    - Actualizaci√≥n de activeSessionId en Athlete.
- Consultar estado de la sala
    - Endpoint GET /room/status que:
        - Consulta todas las sesiones activas (endedAt IS NULL).
        - Devuelve datos del atleta, plan y progreso actual.
    - Posible cache o suscripci√≥n a cambios para mejorar la latencia de actualizaciones.
- Actualizar progreso de ejercicio
    - Endpoint PATCH /progress/{sessionId}/{exerciseId}.
    - Validaci√≥n de integridad:
        - Que el ejercicio pertenezca al plan de la sesi√≥n.
        - Que los sets completados y pesos sean coherentes.
    - Timestamp de √∫ltima actualizaci√≥n (updatedAt).

üîê Seguridad
- Middleware de autenticaci√≥n para entrenadores y atletas.
- Control de acceso para evitar que un atleta modifique sesiones de otros.
- Validaci√≥n de payloads para evitar entradas maliciosas.

2. Frontend (Next.js + React + Tailwind + shadcn)
üìå Funcionalidades
- Pantalla de login/identificaci√≥n de atleta (opcional seg√∫n uso en sala).
- Pantalla de "entrar a la sala"
    - Formulario de inicio de sesi√≥n con selecci√≥n de plan.
    - Confirmaci√≥n de inicio con feedback visual.
- Vista de sala (monitor de estado)
    - Componente con lista de atletas activos, ejercicio actual y sets completados.
    - Actualizaci√≥n peri√≥dica o mediante WebSockets / polling cada X segundos.
- Panel de actualizaci√≥n de ejercicio
    - Interfaz para introducir sets completados y peso usado.
    - Feedback visual al guardar (snackbar, toast, etc.).

3. Base de Datos (PostgreSQL + Prisma)
üìå Modelo de Datos
- Tablas:
    - Athlete, Workout, WorkoutExercise, TrainingSession, Exercise, ExerciseProgress
- Relaciones correctamente modeladas con claves for√°neas.
- √çndices para consultas frecuentes: sesiones activas, ejercicios de workout, progreso por sesi√≥n.

üìå L√≥gica de negocio en queries
- Filtros por sesiones activas.
- C√°lculo de progreso (ejercicio actual, sets realizados vs total).
- Validaciones en cascada (p.ej. que un ejercicio exista dentro del workout).

4. Tiempo real / Sincronizaci√≥n (opcional en MVP pero recomendable)
- Uso de WebSockets (ej. con Socket.IO) o polling peri√≥dico (cada 5‚Äì10 seg).
- Broadcast de actualizaciones cuando un atleta actualiza su progreso.
- Canal centralizado de estado de la sala.

5. DevOps / CI-CD / Entorno
- Deploy autom√°tico (ej. GitHub Actions para Render/Supabase).
- Variables de entorno gestionadas por entorno (.env en local, secretos en Render).
- Logs de errores para backend.
- Protecci√≥n de endpoints mediante tokens/API keys si se accede desde dispositivos compartidos.

‚úÖ Resumen por Historia de Usuario
| Historia                         | Backend                | Frontend                | Base de datos                | Tiempo real                    |
| -------------------------------- | ---------------------- | ----------------------- | ---------------------------- | ------------------------------ |
| Iniciar sesi√≥n de entrenamiento  | `POST /sessions/start` | Formulario de inicio    | `TrainingSession`, `Athlete` | (opcional) emitir nueva sesi√≥n |
| Ver estado actual de la sala     | `GET /room/status`     | Monitor en sala         | Query a sesiones activas     | Recomendado para UX            |
| Actualizar progreso de ejercicio | `PATCH /progress/...`  | Formulario de sets/peso | `ExerciseProgress`           | Emitir progreso actualizado    |

---

## 6. Tickets de Trabajo

> Documenta 3 de los tickets de trabajo principales del desarrollo, uno de backend, uno de frontend, y uno de bases de datos. Da todo el detalle requerido para desarrollar la tarea de inicio a fin teniendo en cuenta las buenas pr√°cticas al respecto. 

**Ticket 1**

üß© Ticket 1 ‚Äì Backend

1. T√≠tulo claro y conciso  
Implementar endpoint para iniciar sesi√≥n de entrenamiento (`POST /sessions/start`)

2. Descripci√≥n detallada  
  - Prop√≥sito:  
    Permitir a un atleta iniciar una sesi√≥n de entrenamiento y quedar registrado como activo en la sala. Es esencial para controlar qu√© usuarios est√°n entrenando y con qu√© plan.

  - Detalles espec√≠ficos:  
    - Recibe un `athleteId` y un `workoutId`.
    - Verifica que el atleta no tenga una sesi√≥n activa.
    - Crea un nuevo registro en `TrainingSession` con `startedAt = now()`.
    - Actualiza el campo `activeSessionId` del atleta.
    - Devuelve el ID de la sesi√≥n creada y los datos del plan.

3. Criterios de aceptaci√≥n  
  - Si el atleta ya tiene una sesi√≥n activa, se devuelve error 409.
  - Si el workoutId no existe, se devuelve error 404.
  - La sesi√≥n se crea correctamente y se registra en la base de datos.
  - El `activeSessionId` se actualiza correctamente.
  - La respuesta devuelve `sessionId`, `startedAt`, `workoutId` y nombre del atleta.

  - Pruebas de validaci√≥n:  
    - Crear sesi√≥n para atleta v√°lido.
    - Intentar iniciar segunda sesi√≥n activa y recibir error.
    - Revisar base de datos y confirmar inserci√≥n.

4. Prioridad  
Alta ‚Äî es la acci√≥n base para que el sistema comience a registrar actividad en la sala.

5. Esfuerzo estimado  
5 puntos de historia (1 d√≠a de trabajo, incluyendo pruebas)

6. Asignar  
Backend Developer

7. Etiquetas  
`backend`, `API`, `MVP`, `alta-prioridad`, `session`, `sala`

8. Comentarios y notas  
- Considerar l√≥gica futura para finalizar sesi√≥n autom√°ticamente tras cierto tiempo.

9. Enlaces o referencias  
- Historia de usuario: *Iniciar una sesi√≥n de entrenamiento*
- Especificaci√≥n OpenAPI

10. Historial de cambios  
- [2025-05-14] Ticket creado

**Ticket 2**

üß© Ticket 2 ‚Äì Frontend

1. T√≠tulo claro y conciso  
Crear formulario de inicio de sesi√≥n de entrenamiento para atleta

2. Descripci√≥n detallada  
  - Prop√≥sito:  
    Permitir a un atleta seleccionar su nombre y plan de entrenamiento desde una interfaz web y registrar el inicio de su sesi√≥n.

  - Detalles espec√≠ficos:  
    - UI: Selector de atleta, selector de workout y bot√≥n ‚ÄúIniciar sesi√≥n‚Äù.
    - Llamada al endpoint `POST /sessions/start` con datos seleccionados.
    - Mostrar mensaje de √©xito o error en pantalla.
    - Dise√±o limpio y responsive (Tailwind + shadcn).

3. Criterios de aceptaci√≥n  
  - Muestra correctamente la lista de atletas y workouts.
  - Realiza la petici√≥n correctamente al backend.
  - Feedback visual ante error o √©xito.
  - Bot√≥n deshabilitado mientras la petici√≥n est√° en curso.

  - Pruebas de validaci√≥n:  
    - Seleccionar opciones y validar el formulario.
    - Simular errores de conexi√≥n o datos inv√°lidos.
    - Validar que al iniciar sesi√≥n se redirige o se limpia el formulario.

4. Prioridad  
Alta ‚Äî permite activar el flujo principal del sistema desde la UI.

5. Esfuerzo estimado  
3 puntos de historia (1 jornada de trabajo)

6. Asignar  
Frontend Developer

7. Etiquetas  
`frontend`, `formulario`, `session`, `UI`, `tailwind`, `react`

8. Comentarios y notas  
- Reutilizable luego como componente embebido en dashboard.

9. Enlaces o referencias  
- Historia de usuario: *Iniciar una sesi√≥n de entrenamiento*
- OpenAPI: `POST /sessions/start`

10. Historial de cambios  
- [2025-05-14] Ticket creado

**Ticket 3**

üß© Ticket 3 ‚Äì Base de Datos

1. T√≠tulo claro y conciso  
Definir y crear tablas para atletas, workouts y sesiones

2. Descripci√≥n detallada  
  - Prop√≥sito:  
    Establecer el modelo de datos inicial que permita a la aplicaci√≥n registrar atletas, entrenamientos y sesiones activas.

  - Detalles espec√≠ficos:  
    - Crear modelos en Prisma:
      - `Athlete` (id, name, activeSessionId, etc.)
      - `Workout` (id, name, exercises, etc.)
      - `TrainingSession` (id, athleteId, workoutId, startedAt, endedAt)
    - Generar migraci√≥n inicial.
    - Insertar datos dummy para pruebas: 3 atletas y 2 workouts.

3. Criterios de aceptaci√≥n  
  - Modelos definidos correctamente en `schema.prisma`.
  - Relaciones correctamente definidas con claves for√°neas.
  - Migraciones aplicadas y sin errores.
  - Datos iniciales visibles al consultar v√≠a Prisma Studio.

  - Pruebas de validaci√≥n:  
    - Ejecutar migraciones en local y en entorno de staging.
    - Verificar integridad referencial.
    - Consultar datos dummy desde el backend.

4. Prioridad  
Alta ‚Äî base esencial para todas las operaciones del sistema.

5. Esfuerzo estimado  
3 puntos de historia (0.5 - 1 jornada)

6. Asignar  
Full Stack o Backend Developer

7. Etiquetas  
`database`, `prisma`, `migraciones`, `MVP`, `modelo de datos`

8. Comentarios y notas  
- A√±adir `createdAt` y `updatedAt` autom√°ticos en todos los modelos.

9. Enlaces o referencias  
- Modelo de datos acordado
- Diagrama Mermaid de relaciones

10. Historial de cambios  
- [2025-05-14] Ticket creado

---

## 7. Pull Requests

> Documenta 3 de las Pull Requests realizadas durante la ejecuci√≥n del proyecto

**Pull Request 1**

**Pull Request 2**

**Pull Request 3**

---

## 8. Extra - Sprint Planning

**üîÅ Sprint 1 ‚Äì Fundamentos del sistema**
Objetivo: Establecer la base del sistema: modelo de datos, backend inicial, y primer flujo funcional (iniciar sesi√≥n de entrenamiento).

üîπ Backlog del Sprint
| Tarea                                                            | Estimaci√≥n | Responsable |
| ---------------------------------------------------------------- | ---------- | ----------- |
| ‚úÖ Definir y crear tablas `Athlete`, `Workout`, `TrainingSession` | 3 pts      | Backend     |
| ‚úÖ Insertar datos dummy iniciales                                 | 1 pt       | Backend     |
| ‚úÖ Implementar endpoint `POST /sessions/start`                    | 5 pts      | Backend     |
| ‚úÖ Crear formulario de inicio de sesi√≥n para atletas              | 3 pts      | Frontend    |
| ‚úÖ Conectar formulario al endpoint                                | 2 pts      | Frontend    |

üß© Entregables
- Primer flujo funcional: atleta inicia sesi√≥n de entrenamiento.
- Datos persistidos y visibles en la base de datos.
- UI b√°sica funcional (aunque no estilizada a√∫n).

**üîÅ Sprint 2 ‚Äì Visualizaci√≥n y seguimiento**
Objetivo: Mostrar el estado de la sala y permitir registrar progreso.

üîπ Backlog del Sprint
| Tarea                                                                       | Estimaci√≥n | Responsable |
| --------------------------------------------------------------------------- | ---------- | ----------- |
| üîÑ Implementar endpoint `GET /room/status`                                  | 4 pts      | Backend     |
| üîÑ Crear vista tipo monitor con lista de atletas activos                    | 4 pts      | Frontend    |
| üîÑ Dise√±ar modelo y endpoint `PATCH /progress/:sessionId/:exerciseId`       | 4 pts      | Backend     |
| üîÑ UI de progreso: formulario por ejercicio con sets, reps, peso            | 4 pts      | Frontend    |
| üîÑ A√±adir relaciones `Exercise`, `WorkoutExercise`, `ExerciseProgress` a DB | 3 pts      | Backend     |


üß© Entregables
- Estado de la sala visible en tiempo real o actualizado peri√≥dicamente.
- Registro de progreso de ejercicios desde UI.

**üîÅ Sprint 3 ‚Äì Mejora, seguridad y despliegue**
Objetivo: Asegurar la calidad del MVP, desplegarlo y aplicar pr√°cticas m√≠nimas de seguridad.

üîπ Backlog del Sprint
| Tarea                                                              | Estimaci√≥n | Responsable |
| ------------------------------------------------------------------ | ---------- | ----------- |
| üîê A√±adir validaciones y control de errores en endpoints           | 3 pts      | Backend     |
| üîê Middleware de autenticaci√≥n b√°sica para paneles (JWT o similar) | 3 pts      | Backend     |
| üöÄ Configurar despliegue en Render + Supabase                      | 4 pts      | Fullstack   |
| üîÑ Estilos base con Tailwind + shadcn/ui                           | 3 pts      | Frontend    |
| üß™ Tests b√°sicos de endpoints (`supertest`, `jest`)                | 3 pts      | Backend     |
| üß™ Tests de UI cr√≠ticos (`vitest`, `playwright`, etc.)             | 3 pts      | Frontend    |

üß© Entregables
- MVP funcional, desplegado y accesible p√∫blicamente.
- Flujo completo probado (manual + automatizado).
- Seguridad m√≠nima aplicada.

**üóÇÔ∏è Vista General**
| Sprint   | Foco                              | Total Puntos |
| -------- | --------------------------------- | ------------ |
| Sprint 1 | Estructura base + flujo de inicio | 14 pts       |
| Sprint 2 | Visualizaci√≥n + progreso          | 19 pts       |
| Sprint 3 | Calidad, seguridad y despliegue   | 19 pts       |
